# -*- coding: utf-8 -*-
"""weather_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Old4Wr8y1Q9cqxhSMlYw72litTQbK300
"""

#importing libraries
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import io
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE
from collections import Counter
from imblearn.under_sampling import RandomUnderSampler

#data loading
from google.colab import files
uploaded = files.upload()
weather = pd.read_csv(io.BytesIO(uploaded['seattle-weather.csv']))

weather.head()
weather.shape
weather.isna().any()

#checking correlation
sns.heatmap(data=weather.corr(),annot=True)

#countplot
sns.countplot(data=weather, x='weather')

fig,axes = plt.subplots(2,2, figsize=(10,10))
cols = ['precipitation', 'temp_max', 'temp_min', 'wind']
for i in range(4):
    sns.boxplot(x='weather', y=cols[i], data=weather, ax=axes[i%2,i//2])

fig, axes = plt.subplots(2,2, figsize=(12,6))
for i in range(len(cols)):
    sns.scatterplot(data=weather.pivot(index='date',columns='weather', values=cols[i]).fillna(0), x='drizzle', y='rain', ax=axes[i%2,i//2])
    axes[i%2,i//2].set_title(cols[i])
    axes[i%2,i//2].set_xticks([])
plt.show()

#there is no correlation between drizzle and rain
#for normalization
def normalizethis(data,cols):
    for x in cols:
        data[x] = data[x]/data[x].max()
normalizethis(weather,cols)
weather.head()

y= weather.pop('weather')
weather.pop('date')
X= weather

x_train,x_test,y_train,y_test = train_test_split(X,y,test_size = 0.3)

lr = LogisticRegression()
rf = RandomForestClassifier(bootstrap=False)
gbc = GradientBoostingClassifier()
dt = DecisionTreeClassifier()
svc = SVC()
knn= KNeighborsClassifier()

lr.fit(x_train,y_train)
rf.fit(x_train,y_train)
gbc.fit(x_train,y_train)
dt.fit(x_train,y_train)
svc.fit(x_train, y_train)
knn.fit(x_train, y_train)

y_pred_lr = lr.predict(x_test)
y_pred_rf = rf.predict(x_test)
y_pred_gbc = gbc.predict(x_test)
y_pred_dt = dt.predict(x_test)
y_pred_svc = svc.predict(x_test)
y_pred_knn = knn.predict(x_test)

print('LogReg Accuracy = {:.2f}'.format(lr.score(x_test,y_test)))
print('RandFor Accuracy = {:.2f}'.format(rf.score(x_test,y_test)))
print('GBC Accuracy = {:.2f}'.format(gbc.score(x_test,y_test)))
print('DT Accuracy = {:.2f}'.format(dt.score(x_test,y_test)))
print('SVC Accuracy = {:.2f}'.format(svc.score(x_test,y_test)))
print('KNN Accuracy = {:.2f}'.format(knn.score(x_test,y_test)))

#classification report
print('LogReg\n',classification_report(y_test,y_pred_lr, zero_division=0))
print('GBC\n',classification_report(y_test,y_pred_gbc, zero_division=0))
print('RF\n',classification_report(y_test,y_pred_rf, zero_division=0))
print('DT\n',classification_report(y_test,y_pred_dt, zero_division=0))
print('KNN\n',classification_report(y_test,y_pred_knn, zero_division=0))

#We can see our recall, precision and f1-score for drizzle and fog is quite poor, our model cannot accurately classify these values.
y_train.value_counts()\

sm = SMOTE(sampling_strategy={'sun':y_train.value_counts()['sun'],'rain':y_train.value_counts()['rain'],'fog':int(y_train.value_counts()['fog']*1.2),
                              'drizzle':int(y_train.value_counts()['drizzle']*1.3), 'snow':int(y_train.value_counts()['snow']*1.5)},random_state=0)
X_res, y_res = sm.fit_resample(x_train, y_train)

rus = RandomUnderSampler(random_state=0, sampling_strategy={'sun':int(y_res.value_counts()['sun']*0.8),'rain':int(y_res.value_counts()['rain']*0.9),
                                                            'fog':y_res.value_counts()['fog'],'drizzle':y_res.value_counts()['drizzle'], 'snow':y_res.value_counts()['snow']})
X_resampled, y_resampled = rus.fit_resample(X_res, y_res)
print(sorted(Counter(y_resampled).items()))

gbc.fit(X_res,y_res)
gbc.score(x_test,y_test)
y_pred2_gbc = gbc.predict(x_test)
print(classification_report(y_test,y_pred2_gbc))

rf.fit(X_res,y_res)
rf.score(x_test,y_test)

lr.fit(X_res,y_res)
lr.score(x_test,y_test)

print('GBC\n',classification_report(y_test,gbc.predict(x_test), zero_division=0))
print('RF\n',classification_report(y_test,rf.predict(x_test), zero_division=0))

gbc.fit(X_resampled,y_resampled)
gbc.score(x_test,y_test)